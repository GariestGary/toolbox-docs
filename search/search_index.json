{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Toolbox is a framework that makes it easier to create games using Unity. Many frequently used things by programmers are taken into account in the toolbox and configured in such a way as to reduce the time and number of lines of code spent on them.</p> <p>Table of contents:</p> <ul> <li>Installing</li> <li>Setup</li> <li>Toolbox Settings</li> <li>MonoCached</li> <li>Updater</li> <li>Traveler</li> <li>Pooler (WIP)</li> <li>Messenger (WIP)</li> <li>Audio Player (WIP)</li> <li>Database (WIP)</li> </ul>"},{"location":"toolbox/audioplayer/","title":"Audio Player","text":"<p><code>Traveler</code> class allows you to easily load/unload scenes (additevely or not) and provides UniTasks for you to manage your call orders in code. It also handles initial logic in scenes.</p>"},{"location":"toolbox/audioplayer/#scene-handler","title":"Scene Handler","text":"<p>Let's imagine that you nedd some initial preparations in scene before all starts working. To do this, you can define your own <code>SceneHandler</code> for this.</p> <pre><code>public class GameSceneHandler: SceneHandler&lt;GameSceneArgs&gt;\n{\n    protected override void SetupScene(GameSceneArgs args)\n    {\n\n    }\n}\n\npublic class GameSceneArgs: SceneArgs\n{\n\n}\n</code></pre> <p>Wait a minute! What this GameSceneArgs class means?! </p> <p>Exactly what you're thinking about! You can provide additional data to the scene when loading it, e.g. you need to create several levels with different difficulties. Creating a scene for each difficulty seems weird, because you have to recreate most of the objects each time if your scene stays the same in general. Instead of that you can set up one scene and change it's logic depending on data provided to it.</p> <p>Here's some example:</p> <pre><code>public class PingPongSceneHandler: SceneHandler&lt;PingPongSceneArgs&gt;\n{\n    [SerializeField] private Enemy m_Enemy;\n\n    protected override void SetupScene(PingPongSceneArgs args)\n    {\n        m_Enemy.SetSpeed(args.EnemySpeed);\n    }\n}\n\n[Serializable]\npublic class PingPongSceneArgs: SceneArgs\n{\n    public float EnemySpeed;\n}\n</code></pre> <p>In that example we're setting up enemy's speed defined by <code>PingPongSceneArgs</code>. <code>SceneArgs</code> class derived from <code>ScriptableObject</code>, so you can create some <code>PingPongSceneArgs</code> assets and bind it to difficulty buttons in your menu scene.</p>"},{"location":"toolbox/audioplayer/#scene-loading","title":"Scene Loading","text":"<p>To load scene simply call:</p> <pre><code>Traveler.LoadScene(\"MySceneName\", new MySceneArgs { data = \"Hello World!\" });\n</code></pre> <p>It will return a UniTask, so you can await it, to manage your calls if you need:</p> <pre><code>await Fader.In(0.2f); \nawait Traveler.LoadScene(\"MySceneName\");\nawait Fader.Out(0.2f);\n</code></pre>"},{"location":"toolbox/audioplayer/#scene-unloading","title":"Scene Unloading","text":"<p>To unload scene simply call:</p> <pre><code>Traveler.UnloadScene(\"MySceneName\");\n</code></pre> <p>You can also unload all scenes, except <code>MAIN</code>, by calling:</p> <pre><code>Traveler.UnloadAllScenes();\n</code></pre> <p>This methods will also returns a UniTask.</p>"},{"location":"toolbox/database/","title":"Database","text":"<p><code>Traveler</code> class allows you to easily load/unload scenes (additevely or not) and provides UniTasks for you to manage your call orders in code. It also handles initial logic in scenes.</p>"},{"location":"toolbox/database/#scene-handler","title":"Scene Handler","text":"<p>Let's imagine that you nedd some initial preparations in scene before all starts working. To do this, you can define your own <code>SceneHandler</code> for this.</p> <pre><code>public class GameSceneHandler: SceneHandler&lt;GameSceneArgs&gt;\n{\n    protected override void SetupScene(GameSceneArgs args)\n    {\n\n    }\n}\n\npublic class GameSceneArgs: SceneArgs\n{\n\n}\n</code></pre> <p>Wait a minute! What this GameSceneArgs class means?! </p> <p>Exactly what you're thinking about! You can provide additional data to the scene when loading it, e.g. you need to create several levels with different difficulties. Creating a scene for each difficulty seems weird, because you have to recreate most of the objects each time if your scene stays the same in general. Instead of that you can set up one scene and change it's logic depending on data provided to it.</p> <p>Here's some example:</p> <pre><code>public class PingPongSceneHandler: SceneHandler&lt;PingPongSceneArgs&gt;\n{\n    [SerializeField] private Enemy m_Enemy;\n\n    protected override void SetupScene(PingPongSceneArgs args)\n    {\n        m_Enemy.SetSpeed(args.EnemySpeed);\n    }\n}\n\n[Serializable]\npublic class PingPongSceneArgs: SceneArgs\n{\n    public float EnemySpeed;\n}\n</code></pre> <p>In that example we're setting up enemy's speed defined by <code>PingPongSceneArgs</code>. <code>SceneArgs</code> class derived from <code>ScriptableObject</code>, so you can create some <code>PingPongSceneArgs</code> assets and bind it to difficulty buttons in your menu scene.</p>"},{"location":"toolbox/database/#scene-loading","title":"Scene Loading","text":"<p>To load scene simply call:</p> <pre><code>Traveler.LoadScene(\"MySceneName\", new MySceneArgs { data = \"Hello World!\" });\n</code></pre> <p>It will return a UniTask, so you can await it, to manage your calls if you need:</p> <pre><code>await Fader.In(0.2f); \nawait Traveler.LoadScene(\"MySceneName\");\nawait Fader.Out(0.2f);\n</code></pre>"},{"location":"toolbox/database/#scene-unloading","title":"Scene Unloading","text":"<p>To unload scene simply call:</p> <pre><code>Traveler.UnloadScene(\"MySceneName\");\n</code></pre> <p>You can also unload all scenes, except <code>MAIN</code>, by calling:</p> <pre><code>Traveler.UnloadAllScenes();\n</code></pre> <p>This methods will also returns a UniTask.</p>"},{"location":"toolbox/install/","title":"Installing","text":""},{"location":"toolbox/install/#install-with-openupm","title":"Install with OpenUPM","text":"<p>Once you have the OpenUPM cli, run the following command:</p> <ul> <li>Go to your Unity project directory</li> </ul> <p><code>cd YOUR_UNITY_PROJECT_DIR</code></p> <ul> <li>Install package: com.volumebox.toolbox</li> </ul> <p><code>openupm add com.volumebox.toolbox</code></p> <p>Alternatively, merge the snippet to Packages/manifest.json </p> <pre><code>{\n    \"scopedRegistries\": [\n        {\n            \"name\": \"package.openupm.com\",\n            \"url\": \"https://package.openupm.com\",\n            \"scopes\": [\n              \"com.volumebox\"\n              \"com.openupm\"\n            ]\n        }\n    ],\n    \"dependencies\": {\n        \"com.volumebox.toolbox\": \"0.2.4\"\n    }\n}\n</code></pre>"},{"location":"toolbox/install/#install-via-package-manager","title":"Install via Package Manager","text":"<ul> <li>open Edit/Project Settings/Package Manager</li> <li> <p>add a new Scoped Registry (or edit the existing OpenUPM entry)</p> <p>Name: <code>package.openupm.com</code></p> <p>URL: <code>https://package.openupm.com</code></p> </li> <li> <p>add following scopes:</p> <p><code>com.volumebox.toolbox</code></p> <p><code>com.dbrizov</code></p> <p><code>com.solidalloy</code></p> <p><code>org.nuget</code></p> <p><code>com.cysharp</code></p> </li> <li> <p>click <code>Save</code> (or <code>Apply</code>)</p> </li> <li>open <code>My Registries</code> packages in package manager window</li> <li>install <code>VolumeBox Toolbox</code></li> </ul>"},{"location":"toolbox/messenger/","title":"Messenger","text":"<p><code>Traveler</code> class allows you to easily load/unload scenes (additevely or not) and provides UniTasks for you to manage your call orders in code. It also handles initial logic in scenes.</p>"},{"location":"toolbox/messenger/#scene-handler","title":"Scene Handler","text":"<p>Let's imagine that you nedd some initial preparations in scene before all starts working. To do this, you can define your own <code>SceneHandler</code> for this.</p> <pre><code>public class GameSceneHandler: SceneHandler&lt;GameSceneArgs&gt;\n{\n    protected override void SetupScene(GameSceneArgs args)\n    {\n\n    }\n}\n\npublic class GameSceneArgs: SceneArgs\n{\n\n}\n</code></pre> <p>Wait a minute! What this GameSceneArgs class means?! </p> <p>Exactly what you're thinking about! You can provide additional data to the scene when loading it, e.g. you need to create several levels with different difficulties. Creating a scene for each difficulty seems weird, because you have to recreate most of the objects each time if your scene stays the same in general. Instead of that you can set up one scene and change it's logic depending on data provided to it.</p> <p>Here's some example:</p> <pre><code>public class PingPongSceneHandler: SceneHandler&lt;PingPongSceneArgs&gt;\n{\n    [SerializeField] private Enemy m_Enemy;\n\n    protected override void SetupScene(PingPongSceneArgs args)\n    {\n        m_Enemy.SetSpeed(args.EnemySpeed);\n    }\n}\n\n[Serializable]\npublic class PingPongSceneArgs: SceneArgs\n{\n    public float EnemySpeed;\n}\n</code></pre> <p>In that example we're setting up enemy's speed defined by <code>PingPongSceneArgs</code>. <code>SceneArgs</code> class derived from <code>ScriptableObject</code>, so you can create some <code>PingPongSceneArgs</code> assets and bind it to difficulty buttons in your menu scene.</p>"},{"location":"toolbox/messenger/#scene-loading","title":"Scene Loading","text":"<p>To load scene simply call:</p> <pre><code>Traveler.LoadScene(\"MySceneName\", new MySceneArgs { data = \"Hello World!\" });\n</code></pre> <p>It will return a UniTask, so you can await it, to manage your calls if you need:</p> <pre><code>await Fader.In(0.2f); \nawait Traveler.LoadScene(\"MySceneName\");\nawait Fader.Out(0.2f);\n</code></pre>"},{"location":"toolbox/messenger/#scene-unloading","title":"Scene Unloading","text":"<p>To unload scene simply call:</p> <pre><code>Traveler.UnloadScene(\"MySceneName\");\n</code></pre> <p>You can also unload all scenes, except <code>MAIN</code>, by calling:</p> <pre><code>Traveler.UnloadAllScenes();\n</code></pre> <p>This methods will also returns a UniTask.</p>"},{"location":"toolbox/monocached/","title":"MonoCached","text":""},{"location":"toolbox/monocached/#basics","title":"Basics","text":"<p>Toolbox has own update system, which wraps around basic Unity's update cycle and doing his own calculations.</p> <p>Main component in this system is <code>MonoCached</code>, which are analogue to MonoBehaviour with some extra described below.</p> <p><code>MonoCached</code> has same update cycle related methods, but named differently. Here are list of all \"overrided\" methods:</p> Basic Analogue <code>Awake</code> <code>Rise</code> <code>Start</code> <code>Ready</code> <code>Update</code> <code>Tick</code> <code>FixedUpdate</code> <code>FixedTick</code> <code>LateUpdate</code> <code>LateTick</code> <code>OnDestroy</code> <code>Destroyed</code> <code>OnEnable</code> <code>OnActivate</code> <code>OnDisable</code> <code>OnDeactivate</code> <p>Also, <code>MonoCached</code> has methods and properties to control lifecycle:</p> Method Description <code>Pause</code> Pauses execution of <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods <code>Resume</code> Resumes execution of <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods <code>EnableGameObject</code> Enables <code>gameObject</code> on which component placed <code>DisableGameObject</code> Disables <code>gameObject</code> on which component placed <code>ProcessIfInactiveSelf</code> Bool property. If enabled, then <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods will be executed even if gameObject inactive self <code>ProcessIfInactiveInHierarchy</code> Bool property. If enabled, then <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods will be executed even if gameObject inactive in hierarchy <code>delta</code> Float property. Delta time, controlled by timescale, interval etc <code>fixedDelta</code> Float property. Fixed delta time, controlled by timescale, interval etc <code>Interval</code> Float property. Sets the interval between calling <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods. Delta time then will be a sum of deltas between last call and next. If setted to 0, then it works usually <p>To use full power of 'Toolbox', just derive your class from <code>MonoCached</code> and override method you need.</p> <p>Here's some example:</p> <pre><code>public class Rocket: MonoCached\n{\n    private float speed = 10;\n    private SpriteRenderer sr;\n\n    protected override void Rise()\n    {\n        sr = GetComponent&lt;SpriteRenderer&gt;();\n    }\n\n    protected override void Tick()\n    {\n        //Here we reducing update calls if we don't see the object\n        if(/*There are some logic to check if object is out of screen*/)\n        {\n            Interval = 1;\n        }\n        else\n        {\n            Interval = 0;\n        }\n\n        //Delta time will be a sum of deltas on every frame between last call of this method and next\n        transform.position = transform.forward * speed * delta;\n    }\n}\n</code></pre> <p>Because of <code>MonoCached</code> derived from MonoBehaviour you can still use <code>Awake</code>, <code>Update</code>, etc...</p>"},{"location":"toolbox/pooler/","title":"Pooler","text":"<p><code>Traveler</code> class allows you to easily load/unload scenes (additevely or not) and provides UniTasks for you to manage your call orders in code. It also handles initial logic in scenes.</p>"},{"location":"toolbox/pooler/#scene-handler","title":"Scene Handler","text":"<p>Let's imagine that you nedd some initial preparations in scene before all starts working. To do this, you can define your own <code>SceneHandler</code> for this.</p> <pre><code>public class GameSceneHandler: SceneHandler&lt;GameSceneArgs&gt;\n{\n    protected override void SetupScene(GameSceneArgs args)\n    {\n\n    }\n}\n\npublic class GameSceneArgs: SceneArgs\n{\n\n}\n</code></pre> <p>Wait a minute! What this GameSceneArgs class means?! </p> <p>Exactly what you're thinking about! You can provide additional data to the scene when loading it, e.g. you need to create several levels with different difficulties. Creating a scene for each difficulty seems weird, because you have to recreate most of the objects each time if your scene stays the same in general. Instead of that you can set up one scene and change it's logic depending on data provided to it.</p> <p>Here's some example:</p> <pre><code>public class PingPongSceneHandler: SceneHandler&lt;PingPongSceneArgs&gt;\n{\n    [SerializeField] private Enemy m_Enemy;\n\n    protected override void SetupScene(PingPongSceneArgs args)\n    {\n        m_Enemy.SetSpeed(args.EnemySpeed);\n    }\n}\n\n[Serializable]\npublic class PingPongSceneArgs: SceneArgs\n{\n    public float EnemySpeed;\n}\n</code></pre> <p>In that example we're setting up enemy's speed defined by <code>PingPongSceneArgs</code>. <code>SceneArgs</code> class derived from <code>ScriptableObject</code>, so you can create some <code>PingPongSceneArgs</code> assets and bind it to difficulty buttons in your menu scene.</p>"},{"location":"toolbox/pooler/#scene-loading","title":"Scene Loading","text":"<p>To load scene simply call:</p> <pre><code>Traveler.LoadScene(\"MySceneName\", new MySceneArgs { data = \"Hello World!\" });\n</code></pre> <p>It will return a UniTask, so you can await it, to manage your calls if you need:</p> <pre><code>await Fader.In(0.2f); \nawait Traveler.LoadScene(\"MySceneName\");\nawait Fader.Out(0.2f);\n</code></pre>"},{"location":"toolbox/pooler/#scene-unloading","title":"Scene Unloading","text":"<p>To unload scene simply call:</p> <pre><code>Traveler.UnloadScene(\"MySceneName\");\n</code></pre> <p>You can also unload all scenes, except <code>MAIN</code>, by calling:</p> <pre><code>Traveler.UnloadAllScenes();\n</code></pre> <p>This methods will also returns a UniTask.</p>"},{"location":"toolbox/setup/","title":"Setup","text":"<p>Once you install the package, you will see setup screen:</p> <p></p> <p>If you don't, just open it from <code>Toolbox/Setup Screen</code></p> <p>First of all, you need to initialize main scene, click 'Initialize Main Scene' button to do this.  It will add 'MAIN' scene to <code>Assets/Scenes/</code> folder and in build settings scenes.  Then you need to create some settings data, click 'Create Settings Data' to do this.</p> <p>After all preparations completed, you can open 'Toolbox Settings' by clicking 'Open Toolbox Settings' or open it from <code>Toolbox/Settings</code>.</p>"},{"location":"toolbox/toolbox-settings/","title":"Toolbox Settings","text":"<p>From this window you can adjust main settings, edit initial pools, set up audios and edit properties in database.</p> <p>'Toolbox Settings' window has four tabs:</p> <ul> <li>Main Settings</li> <li>Pooler</li> <li>Audio Player</li> <li>Database</li> </ul> <p>Let's look all them.</p>"},{"location":"toolbox/toolbox-settings/#main-settings","title":"Main Settings","text":"<p>There you can edit following properties:</p> <ul> <li><code>Resolve Scenes On Play</code>: Changes OnPlay behaviour. If enabled, then Toolbox will close all opened scenes and start all with <code>MAIN</code> scene (after stop playing, all scenes will be restored).</li> <li><code>Time Scale</code>: An ordinary time scale, that affects all scripts, derived from <code>MonoCached</code>.</li> <li><code>Target Frame Rate</code>: Default target frame rate option, which will be setted at startup.</li> <li><code>Initial Scene Name</code>: The scene that will be loaded first after <code>MAIN</code> scene loaded.</li> <li><code>Initial Scene Args</code>: Arguments for initial scene.</li> <li><code>Manual Fade Out</code>: If enabled, then you can manually control when black screen will be faded out after initial scene loaded, otherwise Toolbox automatically fades it out right after initial scene loaded.</li> <li><code>Fade Out Duration</code>: Simply controls fade out duration when <code>Manual Fade Out</code> disabled.</li> </ul>"},{"location":"toolbox/toolbox-settings/#pooler","title":"Pooler","text":"<p>From this window you can edit initial pools list and adjust properties of each.</p> <p>You can create new pool by clicking 'Add Pool' button.</p> <p></p> <p>Each pool has following parameters:</p> <ul> <li><code>Pool Tag</code>: The tag, through which you can retrieve pooled object.</li> <li><code>Prefab</code>: Prefab which pool will instantiate objects.</li> <li><code>Initial Pool Size</code>: Count of an objects tha will be added to the pool at start.</li> </ul> <p></p> <p>To delete pool, simply click button with trash icon.</p> <p>You can also search necessary pool by writing its tag in search field.</p>"},{"location":"toolbox/toolbox-settings/#audio-player","title":"Audio Player","text":"<p>From this window you can edit audio albums list and adjust properties of each.</p> <p>You can create new album by clicking 'Add Album' button.</p> <p></p> <p>Each album has following parameters:</p> <ul> <li><code>Album Name</code>: Name of the album, through which you can get access to clips it containing.</li> <li><code>Use Separate Audio Source</code>: If enabled, then Toolbox will create separate audio source for this album.</li> <li><code>Mixer Group</code>: Mixer group through which you can control volume, effects etc of the audio source, binded to this album.</li> </ul> <p>To delete album click button with trash icon.</p> <p>To add clips in album click 'Add Clip' button.</p> <p></p> <p>Each clip has following parameters:</p> <ul> <li><code>Clip ID</code>: ID of the clip, through which you can retrieve it.</li> <li><code>Audio Clip</code>: Actual audio clip asset.</li> </ul> <p></p> <p>To delete clip click button with trash icon.</p>"},{"location":"toolbox/toolbox-settings/#database","title":"Database","text":"<p>From this window you can define database for your project. If you opening it first time it will look like this:</p> <p></p> <p>To create new database right click in project window and go to <code>Create/Toolbox/Properties Database</code>. It will create new scriptable object with all variables in it. Rename it as you wish and drag into 'Properties' fieeld in 'Database' tab of Toolbox Settings window. After adding database you can define your propertiess.</p> <p></p> <p>To add new property click '+' button.</p> <p></p> <p>Each property has following parameters:</p> <ul> <li><code>ID</code>: ID of the property, through which you can retrieve it.</li> <li><code>Type</code>: Type of the property. Can be one of the following: <code>Bool</code>, <code>Float</code>, <code>Int</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>String</code>.</li> <li><code>Value</code>: Actual value of the property.</li> </ul> <p></p> <p>To delete property click button with trash icon.</p>"},{"location":"toolbox/traveler/","title":"Traveler","text":"<p><code>Traveler</code> class allows you to easily load/unload scenes (additevely or not) and provides UniTasks for you to manage your call orders in code. It also handles initial logic in scenes.</p>"},{"location":"toolbox/traveler/#scene-handler","title":"Scene Handler","text":"<p>Let's imagine that you nedd some initial preparations in scene before all starts working. To do this, you can define your own <code>SceneHandler</code> for this.</p> <pre><code>public class GameSceneHandler: SceneHandler&lt;GameSceneArgs&gt;\n{\n    protected override void SetupScene(GameSceneArgs args)\n    {\n\n    }\n}\n\npublic class GameSceneArgs: SceneArgs\n{\n\n}\n</code></pre> <p>Wait a minute! What this GameSceneArgs class means?! </p> <p>Exactly what you're thinking about! You can provide additional data to the scene when loading it, e.g. you need to create several levels with different difficulties. Creating a scene for each difficulty seems weird, because you have to recreate most of the objects each time if your scene stays the same in general. Instead of that you can set up one scene and change it's logic depending on data provided to it.</p> <p>Here's some example:</p> <pre><code>public class PingPongSceneHandler: SceneHandler&lt;PingPongSceneArgs&gt;\n{\n    [SerializeField] private Enemy m_Enemy;\n\n    protected override void SetupScene(PingPongSceneArgs args)\n    {\n        m_Enemy.SetSpeed(args.EnemySpeed);\n    }\n}\n\n[Serializable]\npublic class PingPongSceneArgs: SceneArgs\n{\n    public float EnemySpeed;\n}\n</code></pre> <p>In that example we're setting up enemy's speed defined by <code>PingPongSceneArgs</code>. <code>SceneArgs</code> class derived from <code>ScriptableObject</code>, so you can create some <code>PingPongSceneArgs</code> assets and bind it to difficulty buttons in your menu scene.</p> <p>You can also override <code>OnSceneUnload</code> method, to do some logic before scene unloads.</p>"},{"location":"toolbox/traveler/#scene-loading","title":"Scene Loading","text":"<p>To load scene simply call:</p> <pre><code>Traveler.LoadScene(\"MySceneName\", new MySceneArgs { data = \"Hello World!\" });\n</code></pre> <p>It will return a UniTask, so you can await it, to manage your calls if you need:</p> <pre><code>await Fader.In(0.2f); \nawait Traveler.LoadScene(\"MySceneName\");\nawait Fader.Out(0.2f);\n</code></pre>"},{"location":"toolbox/traveler/#scene-unloading","title":"Scene Unloading","text":"<p>To unload scene simply call:</p> <pre><code>Traveler.UnloadScene(\"MySceneName\");\n</code></pre> <p>You can also unload all scenes, except <code>MAIN</code>, by calling:</p> <pre><code>Traveler.UnloadAllScenes();\n</code></pre> <p>This methods will also returns a UniTask.</p>"},{"location":"toolbox/traveler/#loading-order","title":"Loading order","text":"<p>After calling <code>LoadScene</code> of Traveler's class, it will be waiting before current operations (loading/unloading scenes) finished his work. Then scene will be loaded usually, and <code>SceneLoadingMessage</code> will be fired. After scene finished loading <code>SceneLoadedMessage</code> fires and all objects in scene will be traversed. If any object contains <code>SceneHandler</code>, then it will be initialized by <code>Updater</code> and starts preparing scene. Then all objects in scene will be initialized and <code>SceneOpenedMessage</code> fires.</p> <p>On <code>UnloadScene</code> call it will be wait until current operations (loading/unloading scenes) done it's work. Then <code>SceneUnloadingMessage</code> fires, if <code>SceneHandler</code> on this scene exists, then <code>OnSceneUnload</code> method invokes and all objects in scene removes from <code>Updater</code> processing. Finally, it unloads scene usually, waits for it's finish and fires <code>SceneUnloadedMessage</code>.</p>"},{"location":"toolbox/updater/","title":"Updater","text":"<p><code>Updater</code> is a base class for process and initialize <code>MonoCached</code> classes. Also you can control time scale for all monos independently of basic Unity's time scale. You can get access to delta time impacted by setted time scale.</p> <p>Here's list of all methods and properties available for managing objects:</p> Method Description <code>UnscaledDelta</code> Returns default <code>Time.deltaTime</code> <code>TimeScale</code> Returns current <code>Updater</code>'s time scale, or sets it to value between 0 and infinte <code>Delta</code> Returns current delta time multiplied by <code>Updater</code>'s time scale <code>InitializeObjects(GameObject[] objs)</code> Invokes Rise and Ready on given GameObjects, and then adds them to process <code>RemoveObjectsFromUpdate(GameObject[] objs)</code> Removes all GameObjects from process <code>InitializeObject(GameObject obj)</code> Invokes Rise and Ready on given GameObject, and then adds it to process <code>InitializeMono(MonoCached mono)</code> Invokes Rise and Ready on given MonoCached, and then adds it to process <code>RemoveMonoFromUpdate(MonoCached mono)</code> Removes given MonoCached from process"}]}